from wsgiref.util import request_uri

import pprint
import datetime
from django.db.models.functions import Concat
from django.shortcuts import get_object_or_404, render
from django.db.models import F, Subquery, OuterRef
from weasyprint import HTML, CSS
from django.contrib.sites.shortcuts import get_current_site
from django.template.loader import get_template
from django.template.response import TemplateResponse
from django.http import HttpResponse
from django.db.models import Max, Case, When, Value, IntegerField, BooleanField
from django.contrib.postgres.aggregates import StringAgg  # PostgreSQL only

from utils.site_allocation_tools import site_allocations
from .forms import (
    ReportListFilterForm,
    StallRegistrationIDFilterForm
)

from accounts.models import (
    Profile
)

from fairs.models import (
    Event,
    Fair,
    PowerBox,
    Zone,
    ZoneMap
)

from registration.models import(
    StallRegistration
)


def reports_listview(request):
    """
    Page as a launch point for the convener reports that can be generated by the system
    """
    template_name = 'dashboards/dashboard_reports_filter.html'
    filterform = ReportListFilterForm(request.POST or None)
    stallregistrationform = StallRegistrationIDFilterForm(request.POST or None)
    form_purpose = filterform.data.get('form_purpose', '')
    alert_message = ''
    zone = None  # Initialize zone to avoid UnboundLocalError
    event = None  # Initialize event to avoid UnboundLocalError

    # Handle HTMX request for filtering
    if request.htmx:
        if form_purpose == 'filter' and filterform.is_valid():
            zone = filterform.cleaned_data.get('zone')  # Use .get() to avoid KeyError
            event = filterform.cleaned_data.get('event')  # Use .get() to avoid KeyError

            # Handle storing session data based on the presence of zone and event
            if event:  # Event is always required
                request.session['selected_event_id'] = event.id
            else:
                alert_message = 'An event must be selected.'

            if zone:  # Zone is optional for certain situations
                request.session['selected_zone_id'] = zone.id

            # Check if we need a response
            if zone and event:
                return TemplateResponse(request, 'partials/zone_selected.html', {'zone': zone, 'event': event})
            elif event:
                return TemplateResponse(request, 'partials/event_selected.html', {'event': event})
            else:
                alert_message = 'Invalid filter selection.'

    # Handle POST request for generating reports
    elif request.method == 'POST':
        if 'marshalllist' in request.POST:
            # Marshalllist requires both zone and event
            zone_id = request.session.get('selected_zone_id')
            event_id = request.session.get('selected_event_id')

            if zone_id and event_id:
                try:
                    zone = Zone.objects.get(id=zone_id)
                    event = Event.objects.get(id=event_id)
                    return marshall_zone_report(request, zone.id, event.id)
                except Zone.DoesNotExist:
                    alert_message = 'The selected zone could not be found.'
                except Event.DoesNotExist:
                    alert_message = 'The selected event could not be found.'
            else:
                alert_message = 'Both a zone and an event must be selected to generate the marshall list.'

        if 'trestlereport' in request.POST:
            # Trestlereport only requires event
            event_id = request.session.get('selected_event_id')

            if event_id:
                try:
                    event = Event.objects.get(id=event_id)
                    return trestle_distribution_report(request, event.id)
                except Event.DoesNotExist:
                    alert_message = 'The selected event could not be found.'
            else:
                alert_message = 'An event must be selected to generate the trestle distribution report.'

        if 'passpack' in request.POST:
            # Pass Pack  only requires stallregistration id to be provided

            if stallregistrationform.is_valid():
            # Access the cleaned data from the form
                stallregistration_id = stallregistrationform.cleaned_data['stallregistration_id']


            if stallregistration_id:
                try:
                    stallregistration = StallRegistration.objects.get(id=stallregistration_id)

                    return fair_passpack_generator(request, stallregistration.id)
                except StallRegistration.DoesNotExist:
                    alert_message = 'The selected stallregistration could not be found.'
            else:
                alert_message = 'A stallregistration must be selected to generate the pass pack.'

    # Default template response for GET and invalid cases
    context = {
        'filterform': filterform,
        'stallregistrationfilterform': stallregistrationform,
        'zone': zone,
        'alert_message': alert_message
    }
    return TemplateResponse(request, template_name, context)


def marshall_zone_report(request, zone, event):
    """
    Function to generate a marshall report for a specific Zone and Event
    """
    current_fair = Fair.currentfairmgr.all().last()
    zone_data = Zone.objects.get(id=zone)
    event_data = Event.objects.get(id=event)

    # Precompute the first and second events for the current fair
    event_query = Event.currenteventfiltermgr.annotate_event_sequence()

    # Get the first and second events
    first_event = event_query.first()
    second_event = event_query[1] if event_query.count() > 1 else None

    # Base queryset for StallRegistration
    site_information = StallRegistration.registrationcurrentallmgr.filter(
        site_allocation__event_site__event__fair=current_fair,
        site_allocation__event_site__site__zone=zone,
    ).select_related('stallholder').annotate(
        allocated_site_name=F('site_allocation__event_site__site__site_name'),
        allocated_site_size=F('site_allocation__event_site__site__site_size__item_name'),
        site_has_power=F('site_allocation__event_site__site__has_power'),
        allocated_site_note=F('site_allocation__event_site__site__site_note'),
        allocated_eventsite_note=F('site_allocation__event_site__notes'),
    )

    # Add event attendance flags, casting BooleanField to IntegerField
    if first_event:
        site_information = site_information.annotate(
            attending_event_1=Case(
                When(site_allocation__event_site__event=first_event, then=Value(1)),
                default=Value(0),
                output_field=IntegerField(),
            )
        )

    if second_event:
        site_information = site_information.annotate(
            attending_event_2=Case(
                When(site_allocation__event_site__event=second_event, then=Value(1)),
                default=Value(0),
                output_field=IntegerField(),
            )
        )

    # Aggregate by site to ensure each site is listed only once
    site_information = site_information.values(
        'id',  # StallRegistration ID
        'manager_vehicle_registration',
        'vehicle_on_site',
        'power_required',
        'allocated_site_name',
        'allocated_site_size',
        'site_has_power',
        'stallholder__phone',
        'stallholder__first_name',
        'stallholder__last_name',
    ).annotate(
        # Consolidate notes into a single string
        allocated_site_note=StringAgg('site_allocation__event_site__site__site_note', delimiter=', ', distinct=True),
        allocated_eventsite_note=StringAgg('site_allocation__event_site__notes', delimiter=', ', distinct=True),
        attending_event_1=Max('attending_event_1'),
        attending_event_2=Max('attending_event_2'),
    ).order_by(
        'allocated_site_name'
    )

    context ={
        'site_information': site_information,
        'zone_data': zone_data,
        'event_data': event_data
    }

    filename= f'marshalls_{event_data.event_name}_report.pdf'

    html_template = get_template('marshallingsitelist.html').render(context)
    pdf_file = HTML(string=html_template, base_url=request.build_absolute_uri()).write_pdf()
    response = HttpResponse(pdf_file, content_type='application/pdf')
    response['Content-Disposition'] = f'filename="{filename}"'
    return response

def trestle_distribution_report(request, event):
    """
    Function to generate a trestle distribution report for a specific Event
    """
    current_fair = Fair.currentfairmgr.all().last()
    event_data = Event.objects.get(id=event)
    # Queryset for StallRegistration
    site_information = StallRegistration.registrationcurrentallmgr.filter(
        site_allocation__event_site__event__fair=current_fair,
        site_allocation__event_site__event=event,
        trestle_required=True,
        booking_status='Booked'
    ).select_related('stallholder').annotate(
        allocated_site_name=F('site_allocation__event_site__site__site_name'),
        allocated_site_trestle_source=F('site_allocation__event_site__site__zone__trestle_source')
    ).values(
        'allocated_site_trestle_source',
        'stallholder__first_name',
        'stallholder__last_name',
        'allocated_site_name',
        'trestle_quantity',
    ).order_by(
        'allocated_site_trestle_source'
    )

    context ={
        'site_information': site_information,
        'event_data': event_data
    }

    filename= f'trestle_distribution_{event_data.event_name}_report.pdf'

    html_template = get_template('trestlelist.html').render(context)
    pdf_file = HTML(string=html_template, base_url=request.build_absolute_uri()).write_pdf()
    response = HttpResponse(pdf_file, content_type='application/pdf')
    response['Content-Disposition'] = f'filename="{filename}"'
    return response

def fair_passpack_generator(request, stallregistration):
    """
    Function to generate a fair passpack for a specific stallregistration
    """
    report_date = datetime.datetime.now()
    current_fair = Fair.currentfairmgr.all().last()

    # Queryset for StallRegistration
    stall_registration = StallRegistration.objects.filter( id=stallregistration).first()

    zone_map_subquery = ZoneMap.objects.filter(
        zone=OuterRef('site_allocation__event_site__site__zone'),
        year=str(report_date.year)
    ).values('map_pdf')[:1]

    # Query to fetch PowerBox description
    power_box_subquery = PowerBox.objects.filter(
        site_powerbox__zone=OuterRef('site_allocation__event_site__site__zone')
    ).values('power_box_description')[:1]

    # Subquery to fetch a single trestle source value
    trestle_source_subquery = StallRegistration.objects.filter(
        id=OuterRef('id')
    ).values('site_allocation__event_site__site__zone__trestle_source')[:1]

    site_list = StallRegistration.registrationcurrentmgr.filter(
        id=stallregistration
    ).select_related('stallholder').annotate(
        allocated_site_name=F('site_allocation__event_site__site__site_name'),
        allocated_site_size=F('site_allocation__event_site__site__site_size__site_size'),
        allocated_event_name=F('site_allocation__event_site__event__event_name'),
        allocated_site_location=F('site_allocation__event_site__site__zone__zone_name'),
        zone_map_path=Subquery(zone_map_subquery),
        powerbox_description=Subquery(power_box_subquery),
        trestle_source=Subquery(trestle_source_subquery),
    ).values(
        'allocated_site_size',
        'allocated_site_name',
        'allocated_event_name',
        'allocated_site_location',
        'zone_map_path',
        'powerbox_description',
        'trestle_source',
    ).order_by(
        'allocated_event_name'
    )

    profile = get_object_or_404(Profile, user=stall_registration.stallholder)

    context ={
        'report_date': report_date,
        'stall_registration': stall_registration,
        'site_list': site_list,
        'profile': profile,
        'current_fair': current_fair,
        'powerbox_description': next(
            (site['powerbox_description'] for site in site_list if site['powerbox_description']), None
        ) if stall_registration.power_required else None,
        'trestle_source': next(
        (site['trestle_source'] for site in site_list if site['trestle_source']), None
        ),
    }

    # Construct URLs for the zone maps
    current_site = get_current_site(request)
    domain = current_site.domain
    print(domain)
    protocol = 'https' if request.is_secure() else 'http'

    for site in site_list:
        if site['zone_map_path']:
            site['zone_map_url'] = f'{protocol}://{domain}/media/{site["zone_map_path"]}'
        else:
            site['zone_map_url'] = None

    filename= f'fair_passpack_for_stallregid{stallregistration}.pdf'

    html_template = get_template('passpack.html').render(context)
    pdf_file = HTML(string=html_template, base_url=request.build_absolute_uri()).write_pdf()
    response = HttpResponse(pdf_file, content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="{filename}"'
    return response