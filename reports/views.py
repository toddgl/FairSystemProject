from wsgiref.util import request_uri

import pprint
from django.shortcuts import render
from django.db.models import F, Subquery, OuterRef
from weasyprint import HTML, CSS
from django.template.loader import get_template
from django.template.response import TemplateResponse
from django.http import HttpResponse
from django.db.models import Max, Case, When, Value, IntegerField, BooleanField
from django.contrib.postgres.aggregates import StringAgg  # PostgreSQL only

from utils.site_allocation_tools import site_allocations
from .forms import (
    ReportListFilterForm
)

from fairs.models import (
    Event,
    Fair,
    Zone
)

from registration.models import(
    StallRegistration
)


def reports_listview(request):
    """
    Page as a launch point for the convener reports that can be generated by the system
    """
    template_name = 'dashboards/dashboard_reports_filter.html'
    filterform = ReportListFilterForm(request.POST or None)
    form_purpose = filterform.data.get('form_purpose', '')
    alert_message = ''
    zone = None  # Initialize zone to avoid UnboundLocalError
    event = None  # Initialize event to avoid UnboundLocalError

    # Handle HTMX request for filtering
    if request.htmx:
        if form_purpose == 'filter' and filterform.is_valid():
            zone = filterform.cleaned_data.get('zone')  # Use .get() to avoid KeyError
            event = filterform.cleaned_data.get('event')  # Use .get() to avoid KeyError

            # Handle storing session data based on the presence of zone and event
            if event:  # Event is always required
                request.session['selected_event_id'] = event.id
            else:
                alert_message = 'An event must be selected.'

            if zone:  # Zone is optional for certain situations
                request.session['selected_zone_id'] = zone.id

            # Check if we need a response
            if zone and event:
                return TemplateResponse(request, 'partials/zone_selected.html', {'zone': zone, 'event': event})
            elif event:
                return TemplateResponse(request, 'partials/event_selected.html', {'event': event})
            else:
                alert_message = 'Invalid filter selection.'

    # Handle POST request for generating reports
    elif request.method == 'POST':
        if 'marshalllist' in request.POST:
            # Marshalllist requires both zone and event
            zone_id = request.session.get('selected_zone_id')
            event_id = request.session.get('selected_event_id')

            if zone_id and event_id:
                try:
                    zone = Zone.objects.get(id=zone_id)
                    event = Event.objects.get(id=event_id)
                    return marshall_zone_report(request, zone.id, event.id)
                except Zone.DoesNotExist:
                    alert_message = 'The selected zone could not be found.'
                except Event.DoesNotExist:
                    alert_message = 'The selected event could not be found.'
            else:
                alert_message = 'Both a zone and an event must be selected to generate the marshall list.'

        if 'trestlereport' in request.POST:
            # Trestlereport only requires event
            event_id = request.session.get('selected_event_id')

            if event_id:
                try:
                    event = Event.objects.get(id=event_id)
                    return trestle_distribution_report(request, event.id)
                except Event.DoesNotExist:
                    alert_message = 'The selected event could not be found.'
            else:
                alert_message = 'An event must be selected to generate the trestle distribution report.'

    # Default template response for GET and invalid cases
    context = {
        'filterform': filterform,
        'zone': zone,
        'alert_message': alert_message
    }
    return TemplateResponse(request, template_name, context)


def marshall_zone_report(request, zone, event):
    """
    Function to generate a marshall report for a specific Zone and Event
    """
    current_fair = Fair.currentfairmgr.all().last()
    zone_data = Zone.objects.get(id=zone)
    event_data = Event.objects.get(id=event)

    # Precompute the first and second events for the current fair
    event_query = Event.currenteventfiltermgr.annotate_event_sequence()

    # Get the first and second events
    first_event = event_query.first()
    second_event = event_query[1] if event_query.count() > 1 else None

    # Base queryset for StallRegistration
    site_information = StallRegistration.registrationcurrentallmgr.filter(
        site_allocation__event_site__event__fair=current_fair,
        site_allocation__event_site__site__zone=zone,
    ).select_related('stallholder').annotate(
        allocated_site_name=F('site_allocation__event_site__site__site_name'),
        allocated_site_size=F('site_allocation__event_site__site__site_size__item_name'),
        site_has_power=F('site_allocation__event_site__site__has_power'),
        allocated_site_note=F('site_allocation__event_site__site__site_note'),
        allocated_eventsite_note=F('site_allocation__event_site__notes'),
    )

    # Add event attendance flags, casting BooleanField to IntegerField
    if first_event:
        site_information = site_information.annotate(
            attending_event_1=Case(
                When(site_allocation__event_site__event=first_event, then=Value(1)),
                default=Value(0),
                output_field=IntegerField(),
            )
        )

    if second_event:
        site_information = site_information.annotate(
            attending_event_2=Case(
                When(site_allocation__event_site__event=second_event, then=Value(1)),
                default=Value(0),
                output_field=IntegerField(),
            )
        )

    # Aggregate by site to ensure each site is listed only once
    site_information = site_information.values(
        'id',  # StallRegistration ID
        'manager_vehicle_registration',
        'vehicle_on_site',
        'power_required',
        'allocated_site_name',
        'allocated_site_size',
        'site_has_power',
        'stallholder__phone',
        'stallholder__first_name',
        'stallholder__last_name',
    ).annotate(
        # Consolidate notes into a single string
        allocated_site_note=StringAgg('site_allocation__event_site__site__site_note', delimiter=', ', distinct=True),
        allocated_eventsite_note=StringAgg('site_allocation__event_site__notes', delimiter=', ', distinct=True),
        attending_event_1=Max('attending_event_1'),
        attending_event_2=Max('attending_event_2'),
    ).order_by(
        'allocated_site_name'
    )

    context ={
        'site_information': site_information,
        'zone_data': zone_data,
        'event_data': event_data
    }

    filename= f'marshalls_{event_data.event_name}_report.pdf'

    html_template = get_template('marshallingsitelist.html').render(context)
    pdf_file = HTML(string=html_template, base_url=request.build_absolute_uri()).write_pdf()
    response = HttpResponse(pdf_file, content_type='application/pdf')
    response['Content-Disposition'] = f'filename="{filename}"'
    return response

def trestle_distribution_report(request, event):
    """
    Function to generate a trestle distribution report for a specific Event
    """
    current_fair = Fair.currentfairmgr.all().last()
    event_data = Event.objects.get(id=event)
    # Queryset for StallRegistration
    site_information = StallRegistration.registrationcurrentallmgr.filter(
        site_allocation__event_site__event__fair=current_fair,
        site_allocation__event_site__event=event,
        trestle_required=True,
        booking_status='Booked'
    ).select_related('stallholder').annotate(
        allocated_site_name=F('site_allocation__event_site__site__site_name'),
        allocated_site_trestle_source=F('site_allocation__event_site__site__zone__trestle_source')
    ).values(
        'allocated_site_trestle_source',
        'stallholder__first_name',
        'stallholder__last_name',
        'allocated_site_name',
        'trestle_quantity',
    ).order_by(
        'allocated_site_trestle_source'
    )

    context ={
        'site_information': site_information,
        'event_data': event_data
    }

    filename= f'trestle_distribution_{event_data.event_name}_report.pdf'

    html_template = get_template('trestlelist.html').render(context)
    pdf_file = HTML(string=html_template, base_url=request.build_absolute_uri()).write_pdf()
    response = HttpResponse(pdf_file, content_type='application/pdf')
    response['Content-Disposition'] = f'filename="{filename}"'
    return response
